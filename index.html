<html>
    <head>
        <meta charset="UTF-8">
        <script type="text/javascript" src="Generate_Menu.js"></script>
        <link rel="stylesheet" href="Menu.css"></link>
        <link rel="stylesheet" href="//unpkg.com/@highlightjs/cdn-assets@11.2.0/styles/default.min.css">
        <script src="//unpkg.com/@highlightjs/cdn-assets@11.2.0/highlight.min.js"></script>
        <link rel="stylesheet" href="Dark.css"></link>
     </head>
    <body>
        <div class="Static1">
            <div class="Menu">
                <ul id="menu">
                    
                </ul>
            <!-- <audio src="Album_pt5.mp3" class="Music" controls preload="metadata" autoplay loop></audio>  -->
            </div>
        </div>

        <div class="Static2">
            <div class="Main" id="main">
                <h3 id="Objects">Objects</h3>
                <p>
                    In Evie everything is based on the consept of objects.
                    <br/>
                    <br/>
                    To construct an object, you need at least one defined word (these can be keywords, already defined object names or both) and a non defined word.
                    <br/>
                    <br/>
                    This non defined word is going to represent the name of that object.
                    <br/>
                    <br/>
                    Here's an example of what i mean:
                    <pre>
                        <code class="language-cpp">
    type A  #Name of the object is 'A' and it's type is 'type'
    A B     #Name of the object is 'B' and it's type is 'A' 
    B ptr C #Name of the object is 'C' and it's type is 'B ptr'
                        </code>
                    </pre>
                    
                    When the object has been defined the inheritted words are removed from the source code list ans only the name remains there.
                    The defined object is also pushed into the difinition list if the current scope.

                </p>

                <h3 id="Classes">Classes</h3>
                <p>
                    Now that everything has been parsed into objects.
                    The compiler looks for context so that it can start adding to the AST more complex structures.
                    <br/>
                    <br/>
                    These complex structures contain classes.
                    <br/>
                    <br/>
                    But how does the compiler tell apart classes from functions?
                    <br/>
                    <br/>
                    here is the syntax of both of them:

                    <pre>
                        <code class="language-cpp">
    int A{
        ..
    }
    int B(){

    }
                        </code>
                    </pre>

                    The above intails one class that inheriths int and is named 'A'.
                    The other one is a function that return int and is named 'B'.
                    <br/>
                    <br/>
                    The compiler tells them from apart by knowing which one takes what amount of paranthesis and what type'd are those parenthesis.
                    <br/>
                    <br/>


                </p>
                
                <h3 id="Base types">Base types</h3>
                <p>
                    In Evie there are no pre defined base types in the compiler source code.
                    But don't fret, you can make your own base types.
                    <br/>
                    <br/>
                    The compiler gives us access to modify some atributes of a sertain class.
                    These atributes are: 
                    - format
                    Format can be integer or decimal.
                    - size
                    Size tell's the compiler what size is the class in guestion.
                    The Size is expressed in bytes.

                    <pre>
                        <code class="language-cpp">
    type integer{
        size = 4
        format = integer
    }
                        </code>
                    </pre>

                    The current implementation of the base types are located in STD/Types.e


                </p>

                <h3 id="Functions imports">Functions imports</h3>
                <p>
                    When a function is imported the return type and the parameters are represented as integers and with decimal or integer word to represent the format.
                    <br/>
                    <br/>
                    When the parser phase has gone by and the post-prosessor phase has began. The shattered information of the parameters and return types size and format are combined.
                    
                </p>

                <h3 id="File include">File include</h3>
                <p>
                    File including is another advanced feature in Evie.
                    The file include system can import functions from:
                    <br/>
                    - Dll files
                    <br/>
                    - Lib files
                    <br/>
                    - Evie files
                    <br/>
                    - Assembly files
                    <br/>
                    - URL
                    <br/>
                    <br/>
                    The system that handles these file includes is called Docker.
                    The Docker tell's the difference between those file types above by reading the magic number in the header of that file.
                    <br/>
                    <br/>
                    Normal and assembly files dont have any magic numbers, 
                    so for assembly files to work you need to put at the start of the assembly file this text:
                    <br/> 
                    "#analyze". 
                    <br/>
                    In the future, Docker is going to fix this need of "#analyze" at the start of the file by reading the file type from the file name, as well as the magic number in the header of that file.
                </p>

                <h3 id="Templates">Templates</h3>
                <p>
                    At Parser time the template functions and template classes are stored as template users. 
                    If however the template class is defined during a object definition, the template class will be copied and this copied version will be overwritten it's all template usages by the new template type.

                    <pre class="language-cpp">
                        <code>
    type A&ltT&gt{
        T ptr Member1 = Allocate&ltT&gt(123)
    }

    int main(){
        #at this X variable definition stage the template class has been copied,
        #and the copied version is going to be overwritten by the new template type.
        A&ltint&gt X.A()
        retrun X.Member1[0]
    }
                        </code>
                    </pre>

                    But if there is a function that is not inside a template type class, this template function is going to be copied after the parsing sequense at post-prosessor.
                    This because wemight not be able to tell what function to call if there are multiple function overloads.

                </p>

                <h3 id="Pointers">Pointers</h3>
                <p>
                    
                </p>

                <h3 id="Function pointters">Function pointters</h3>
                <p>
                    Function pointters are one of the dynamic features Evie has.

                    One of the main reasons i wanted to create this document.
                    You see, function pointters in Evie are not same as in for example. C++.

                    First let's create some functions for our example.

                    <pre>
                        <code class="language-cpp">
    int Sum(int x, int y) {
        return x + y 
    }

    float Sum(float x, float y) {
        return x + y
    }
                        </code>
                    </pre>

                    We have to create a function pointters object:
                    
                    
                    <pre>
                        <code class="language-cpp">
    func ptr A = Sum
                        </code>
                    </pre>

                    You may realize by now that something doesn't seem right. 
                    And you are right, this is where Evie will differ from most programming languages.

                    Byt how does this even work? Well it doesn't (:

                    For this to work the assing operator to needs to find the right suitable function to get it's address loaded,
                    this happends when you call the function pointter.

                    <pre>
                        <code class="language-cpp">
    int Result = A(1, 2)
                        </code>
                    </pre>

                    Think what just happened like this.
                    The name 'Sum' represents all functions that are named 'Sum'.
                    This 'Sum' is like a branch and the different function overloads are like leaves on that branch.
                    By calling the function pointter we state what leave from the branch we want to call.

                    <pre>
                        <code class="language-cpp">
    #this is where we tell function pointter A points into function branch 'Sum'. 
    #But no address is loaded yet.
    func ptr A = Sum  
    
    #Now we fetch the function from the branch we just set earlier.
    int Result = A(1, 2)
    
    #At this point we know that the function we load is the 'int Sum(int, int)'.
    #Now we go back to the load moment and set the right function overload.

                        </code>
                    </pre>
                </p>

            </div>
        </div>

        <script>
            Generate_List()
            hljs.highlightAll();
        </script>
    </body>

</html>